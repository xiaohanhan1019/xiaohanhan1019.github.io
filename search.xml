<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deep_Learning_Week_One</title>
      <link href="/2019/01/21/Deep-Learning-Week-One/"/>
      <url>/2019/01/21/Deep-Learning-Week-One/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Binary-Classification-二分分类"><a href="#1-Binary-Classification-二分分类" class="headerlink" title="1. Binary Classification (二分分类)"></a>1. Binary Classification (二分分类)</h3><p>$\alpha \in A$</p><p>$$<br>\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常量池</title>
      <link href="/2019/01/17/Java-Constant-Pool/"/>
      <url>/2019/01/17/Java-Constant-Pool/</url>
      
        <content type="html"><![CDATA[<h3 id="1-常量池"><a href="#1-常量池" class="headerlink" title="1. 常量池"></a>1. 常量池</h3><ul><li>相同的值只存储一份，节省内存，共享访问，提高运行效率</li></ul><a id="more"></a><h3 id="2-基本类型的包装类"><a href="#2-基本类型的包装类" class="headerlink" title="2.基本类型的包装类"></a>2.基本类型的包装类</h3><ul><li><code>Boolean</code> <code>Byte</code> <code>Short</code> <code>Integer</code> <code>Long</code> <code>Character</code> <code>Float</code> <code>Double</code> 八种基本类型的包装类</li><li>常量值范围<ul><li><code>Boolean</code>：true, false</li><li><code>Byte</code> <code>Character</code> : \u0000 - \u007f</li><li><code>Short</code> <code>Integer</code> <code>Long</code> : -128 - 127</li><li><code>Float</code> <code>Double</code> : 无常量池</li></ul></li></ul><h3 id="3-与equals"><a href="#3-与equals" class="headerlink" title="3.==与equals()"></a>3.==与equals()</h3><ul><li>对于基本数据类型，<code>==</code>比较他们的数值</li><li>对于对象，<code>==</code>比较两个对象在内存中的存放地址，可以通过重写<code>equals()</code>来比较两个对象的内容是否相等</li></ul><h3 id="4-字符串常量"><a href="#4-字符串常量" class="headerlink" title="4.字符串常量"></a>4.字符串常量</h3><ul><li>Java为常量字符串建立了常量池缓存机制<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="hljs-string">"abc"</span>;</span><br><span class="line">String s2 = <span class="hljs-string">"ab"</span> + <span class="hljs-string">"c"</span>;</span><br><span class="line">String s3 = <span class="hljs-string">"a"</span> + <span class="hljs-string">"b"</span> + <span class="hljs-string">"c"</span>; <span class="hljs-comment">//都是常量，是确定的，编译器将优化</span></span><br><span class="line">System.out.println(s1==s2); <span class="hljs-comment">//true</span></span><br><span class="line">System.out.println(s1==s3); <span class="hljs-comment">//true</span></span><br><span class="line">System.out.println(s2==s3); <span class="hljs-comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-基本类型的包装类和字符串的两种创建方式"><a href="#5-基本类型的包装类和字符串的两种创建方式" class="headerlink" title="5.基本类型的包装类和字符串的两种创建方式"></a>5.基本类型的包装类和字符串的两种创建方式</h3><ul><li>字面值赋值，放在栈内存<strong>（将被常量化）</strong><ul><li><code>Integer a = 1;</code> </li><li><code>String b = &quot;abc&quot;;</code></li></ul></li><li>new对象进行创建，放在堆内存<strong>（不会常量化）</strong><ul><li><code>Integer c = new Integer(1);</code></li><li><code>String d = new String(&quot;abc&quot;);</code></li></ul></li><li>栈内存读取速度快，容量小</li><li>堆内存读取速度慢，容量大，可以通俗的理解为Java认为new出来的对象所占内存较大（不确定，而字面值是确定的），所以需要放在堆内存</li></ul><h3 id="6-Integer常量池的例子"><a href="#6-Integer常量池的例子" class="headerlink" title="6.Integer常量池的例子"></a>6.Integer常量池的例子</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>;</span><br><span class="line">Integer i2 = <span class="hljs-number">10</span>; <span class="hljs-comment">//自动装箱，10本来只是int，是基本类型，而我们需要把它变成一个对象，相当于包装了一层</span></span><br><span class="line">System.out.println(i1==i2) <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//自动拆箱 基本类型和包装类进行比较，包装类自动拆箱</span></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(i1==i3) <span class="hljs-comment">//true 同理，包装类自动拆箱</span></span><br><span class="line">System.out.println(i2==i3) <span class="hljs-comment">//false i2,i3都是对象，而i2是常量，在常量池，i3是new出来的对象，在堆内存中 </span></span><br><span class="line"></span><br><span class="line">Integer i4 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">5</span>);</span><br><span class="line">Integer i5 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">5</span>);</span><br><span class="line">System.out.println(i1 == (i4+i5)); <span class="hljs-comment">//true</span></span><br><span class="line">System.out.println(i1 == (i4+i5)); <span class="hljs-comment">//true</span></span><br><span class="line">System.out.println(i1 == (i4+i5)); <span class="hljs-comment">//true</span></span><br><span class="line"><span class="hljs-comment">//i4+i5的操作将会使i4,i5自动拆箱为基本类型并运算得到10，而根据之前所提到的，基本类型和包装类进行比较，包装类自动拆箱，所以都为true</span></span><br><span class="line"></span><br><span class="line">Integer i6 = i4 + i5;</span><br><span class="line">System.out.println(i1==i6); <span class="hljs-comment">//true，同理i4+i5的操作使i4,i5自动拆箱，得到10，相当于Integer i6 = 10;</span></span><br><span class="line">System.out.println(i3==i6); <span class="hljs-comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="7-String常量池的例子"><a href="#7-String常量池的例子" class="headerlink" title="7.String常量池的例子"></a>7.String常量池的例子</h3><p>字符串常量池存在于方法区，方法区包含的都是在整个程序中唯一的元素，如static变量</p><ul><li><p>一个简单的例子</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="hljs-string">"abc"</span>;</span><br><span class="line">String s2 = <span class="hljs-string">"abc"</span>;</span><br><span class="line">String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);</span><br><span class="line">String s4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"abc"</span>);</span><br><span class="line">System.out.println(s1==s2); <span class="hljs-comment">//true 都是常量池</span></span><br><span class="line">System.out.println(s1==s3); <span class="hljs-comment">//false 一个是栈内存，一个是堆内存</span></span><br><span class="line">System.out.println(s3==s4); <span class="hljs-comment">//false 都是堆内存，但是不同对象</span></span><br></pre></td></tr></table></figure></li><li><p>图解：(<code>&quot;</code>由<code>&#39;</code>代替)</p><pre class="mermaid">graph LR;subgraph 方法区  s['abc']endsubgraph 堆  A["s3 = new String('abc')"]  B["s4 = new String('abc')"]endsubgraph 栈  s1  s2  s3  s4ends1-->ss2-->sA-->sB-->ss3-->As4-->B</pre></li><li>更为复杂的例子<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="hljs-string">"abcdef"</span>;</span><br><span class="line">String s6 = s1 + <span class="hljs-string">"def"</span>; <span class="hljs-comment">//涉及到变量（不确定的），编译器不会优化</span></span><br><span class="line">String s7 = <span class="hljs-string">"abc"</span> + <span class="hljs-string">"def"</span>; <span class="hljs-comment">//都是常量，编译器会优化成abcdef</span></span><br><span class="line">String s8 = <span class="hljs-string">"abc"</span> + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"def"</span>); <span class="hljs-comment">//涉及到new对象，编译器不优化</span></span><br><span class="line">System.out.println(s6==s7); <span class="hljs-comment">//false</span></span><br><span class="line">System.out.println(s6==s8); <span class="hljs-comment">//false</span></span><br><span class="line">System.out.println(s7==s8); <span class="hljs-comment">//false</span></span><br><span class="line">System.out.println(s5==s7); <span class="hljs-comment">//true</span></span><br><span class="line"></span><br><span class="line">String s9 = s3 + <span class="hljs-string">"def"</span>; <span class="hljs-comment">//由于s3是new的，涉及到new对象，编译器不优化</span></span><br><span class="line">System.out.println(s7==s9); <span class="hljs-comment">//false</span></span><br><span class="line"><span class="hljs-comment">//对于s5~s9，只有s5,s7是在常量池中，其余都在堆内存上，且地址互不相同</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Tutorial</title>
      <link href="/2019/01/14/Vim-Tutorial/"/>
      <url>/2019/01/14/Vim-Tutorial/</url>
      
        <content type="html"><![CDATA[<p>This tutorial includes some basic vim commands and I hope that it will be helpful.</p><a id="more"></a><h3 id="1-Moving-the-cursor"><a href="#1-Moving-the-cursor" class="headerlink" title="1.Moving the cursor"></a>1.Moving the cursor</h3><ul><li><code>h</code> : left</li><li><code>j</code> : down</li><li><code>k</code> : up</li><li><code>l</code> : right</li></ul><p>It takes time to get used to it.</p><h3 id="2-Navigation"><a href="#2-Navigation" class="headerlink" title="2.Navigation"></a>2.Navigation</h3><ul><li><code>w</code>: move the cursor one word forward (to the first letter)</li><li><code>b</code> : one word backward (also to the first letter)</li><li><code>e</code> : one word forward (to the last letter)</li><li><code>fx</code> : forward to the letter <code>x</code></li><li><code>(</code> : to the start of the sentence</li><li><code>)</code> : start of the sentence</li><li><code>0</code> : start of line</li><li><code>$</code> : end of line </li><li><code>{</code> : start of paragraph</li><li><code>}</code> : end of paragraph </li><li><code>G</code> : end of file<ul><li><code>ctrl+G</code> : to see the cursor location and file status </li></ul></li><li><code>gg</code> : start of file</li><li><code>xG</code> : to the number <code>x</code> line of file<ul><li><strong>typing a number before a motion repeats it that many times!</strong></li></ul></li></ul><h3 id="3-Delete"><a href="#3-Delete" class="headerlink" title="3.Delete"></a>3.Delete</h3><ul><li><code>x</code>: delete the character at the cursor</li><li><code>dw</code>: delete all the characters between the cursor and the first letter of the next word<ul><li>e.g. Please de<code>l</code>ete the word. (Assume the cursor is at <code>l</code>)</li><li>After you press dw, the sentence becomes <code>Please dethe word delete</code></li></ul></li><li><code>de</code>: delete all the characters between the cursor and the next space<ul><li>e.g. Please de<code>l</code>ete the word. (Assume the cursor is at <code>l</code>)</li><li>After you press de, the sentence becomes <code>Please de the word delete</code></li></ul></li><li><code>d$</code> : delete to end of line</li><li><code>dd</code> : delete whole line</li><li><code>p</code> : After you delete something, press p to paste things you delete wherever you like.</li></ul><h3 id="4-Insert"><a href="#4-Insert" class="headerlink" title="4.Insert"></a>4.Insert</h3><ul><li><code>a</code> : insert after the cursor</li><li><code>A</code> : insert after the end of line</li><li><code>i</code> : insert before the cursor</li><li><code>I</code> : insert before the start of line </li><li><code>o</code> : insert in the next line</li><li><code>O</code> : insert in the previous line</li></ul><h3 id="5-Search"><a href="#5-Search" class="headerlink" title="5.Search"></a>5.Search</h3><ul><li><code>/yourSearchString + &lt;Enter&gt;</code> : search for <code>yourSearchString</code><ul><li><code>n</code> : to search for the same string again (press <code>&lt;Enter&gt;</code> to exit)</li><li><code>N</code> : to search for the same string again, but in opposite direction</li><li><code>ctrl+o</code> : to go back to where you came from</li><li><code>ctrl+i</code> : to go forward</li><li>set option<ul><li><code>:set ic</code> : ignore case</li><li><code>:set noic</code> : disable ignore case</li><li><code>:set hls</code> : highlight the matches</li><li><code>:set nohls</code> : disable highlight matches</li><li><code>:set is</code> : increase search</li><li><code>:set nois</code>: disable increase search</li></ul></li></ul></li><li><code>%</code> : move the cursor to the other matching parenthesis</li></ul><h3 id="6-Replace"><a href="#6-Replace" class="headerlink" title="6.Replace"></a>6.Replace</h3><ul><li><code>rx</code> : replace the character at cursor with <code>x</code></li><li><code>ce</code> : almost the same as <code>de</code>, but this time will place you in Insert Mode</li><li><code>s/old/new</code> : replace the first occurrence of ‘old’ with ‘new’</li><li><code>s/old/new/g</code> : replace all occurrence of ‘old’ with ‘new’ in one line</li><li><code>#,#/old/new/g</code> : #,# are the line numbers of the range of lines where the replace should be done</li><li><code>%s/old/new/g</code> : replace all occurrence of ‘old’ with ‘new’ in the whole file</li><li><code>%s/old/new/g</code> : replace all occurrence of ‘old’ with ‘new’ in the whole file, with a prompt whether to replace or not</li></ul><h3 id="7-Undo-amp-Redo"><a href="#7-Undo-amp-Redo" class="headerlink" title="7.Undo &amp; Redo"></a>7.Undo &amp; Redo</h3><ul><li><code>u</code> : undo the last command</li><li><code>U</code> : undo the command excuting on the while line</li><li><code>ctrl+R</code> : redo the command</li></ul><h3 id="8-Copy-amp-Paste"><a href="#8-Copy-amp-Paste" class="headerlink" title="8.Copy &amp; Paste"></a>8.Copy &amp; Paste</h3><ul><li><code>y</code> : to copy</li><li><code>p</code> : to paste<ul><li>e.g. Start Visual Mode with <code>v</code> and move the cursor to chose whatever you want, type <code>y</code> to copy the highlighted text and type <code>p</code> to paste the text.</li></ul></li></ul><h3 id="9-Others"><a href="#9-Others" class="headerlink" title="9.Others"></a>9.Others</h3><ul><li><code>.</code> : repeat the last command</li><li><code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code> : many commands follow this pattern<ul><li>e.g. <code>0y$</code> means copy the whole line<ul><li><code>0</code> move the cursor to the start of line</li><li><code>y</code> copy</li><li><code>$</code> move the cursor to the end of line</li></ul></li></ul></li><li><code>ctrl+n</code> : auto complete</li></ul>]]></content>
      
      
      <categories>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
